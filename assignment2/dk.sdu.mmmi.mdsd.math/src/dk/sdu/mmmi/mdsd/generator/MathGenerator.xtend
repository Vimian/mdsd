/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.Exp
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Primary
import dk.sdu.mmmi.mdsd.math.Number
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static compute(MathExp math) { 
		val result = math.exp.computeExp
		variables.put(math.name, result)
		return variables
	}
	
	def static int computeExp(Exp exp) {
		if (exp.left instanceof Number) {
			var left = exp.left.computePrim
			System.out.println(exp.exps.size())
			
			for (var i = 0; i < exp.exps.size(); i++) {
				if (exp.exps.get(i) instanceof Number) {
					switch exp.operators.get(i) {
						Plus: left+=(exp.exps.get(i) as Number).computePrim
						Minus: left-=(exp.exps.get(i) as Number).computePrim
						Mult: left*=(exp.exps.get(i) as Number).computePrim
						Div: left/=(exp.exps.get(i) as Number).computePrim
					}
				} else {
					System.out.println("\n \n IT IS NOT A NUMBER!! \n")
					return 0
				}
			}
			
			return left
		} else {
			System.out.println("\n \n IT IS NOT A NUMBER!! \n")
			return 0
		}
	}
	
	def static int computePrim(Primary factor) {
		System.out.print(factor)
		if (factor instanceof Number) {
		    return (factor as Number).value
		} else if (factor instanceof Parenthesis){
			System.out.print((factor as Parenthesis))
		} else if (factor instanceof VariableUse) {
			System.out.print((factor as VariableUse))
		}
		0
	}

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
}
