/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Divi
import dk.sdu.mmmi.mdsd.math.Exp
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Multi
import dk.sdu.mmmi.mdsd.math.Plus
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.Primary
import dk.sdu.mmmi.mdsd.math.LetVariable
import dk.sdu.mmmi.mdsd.math.VariableUse

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	static Map<String, Integer> letVariables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		
		val result = math.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static compute(MathExp math) {
		for (var i = 0; i < math.variables.size; i++) {
			letVariables = new HashMap()
			
			val result = math.variables.get(i).exp.computeExp
		
			variables.put(math.variables.get(i).name, result)
		}
		
		return variables
	}
	
	def static int computeExp(Exp exp) {
		// Handle primary expressions first
		if (exp instanceof Primary) {
			return exp.computePrim
		}

		if (exp instanceof Plus) {
			return exp.computeExp
		}
		
		if (exp instanceof Minus) {
			return exp.computeExp
		}
		
		if (exp instanceof Multi) {
			return exp.computeExp
		}
		
		if (exp instanceof Divi) {
			return exp.computeExp
		}
		
		return 0
	}
	
	def static int computeExp(Plus plus) {		
		return plus.left.computeExp + plus.right.computeExp
	}
	
	def static int computeExp(Minus minus) {		
		return minus.left.computeExp - minus.right.computeExp
	}
	
	def static int computeExp(Divi divi) {
		return divi.left.computeExp / divi.right.computePrim
	}
	
	def static int computeExp(Multi multi) {
		return multi.left.computeExp * multi.right.computePrim
	}
	
	def static int computePrim(Primary primary) {
		if (primary instanceof MathNumber) {
			return primary.value
		} else if (primary instanceof Parenthesis) {
			return primary.exp.computeExp
		} else if (primary instanceof LetVariable) {
			val initValue = primary.value.computeExp
			val oldValue = letVariables.get(primary.name)
			
			letVariables.put(primary.name, initValue)
			
			val result = primary.exp.computeExp
			
			letVariables.put(primary.name, oldValue)
			
			return result
		} else if (primary instanceof VariableUse) {
			if (letVariables.containsKey(primary.ref.name)) {
				return letVariables.get(primary.ref.name)
			} else if (variables.containsKey(primary.ref.name)) {
				return variables.get(primary.ref.name)
			}
			
			return 0
		}
		return 0
	}
	
	

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
}
